/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Text Input Context
 #	author : miyako
 #	2019/06/27
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Text-Input-Context.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
		CommandDispatcherInMainProcess (selector, params);
	}
	catch(...)
	{

	}
}

void CommandDispatcherInMainProcess (PA_long32 selector, PA_PluginParameters params) {
    
    switch(selector)
    {
            // --- Text Input Context
            
            /* PA_RunInMainProcess is not threadSafe */
            
        case 1 :
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)_o_INPUT_SOURCES_LIST, params);
            break;
            
        case 2 :
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)_o_Get_input_source, params);
            break;
            
        case 3 :
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)SET_INPUT_SOURCE, params);
            break;
            
        case 4 :
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)GET_INPUT_SOURCE_LOCALES, params);
            break;
            
        case 5 :
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)SET_INPUT_SOURCE_LOCALES, params);
            break;
            
        case 6 :
            INPUT_SOURCES_LIST(params);/* PA_RunInMainProcess not compatible with PA_CollectionRef params */
            break;
            
        case 7 :
            Get_input_source(params);/* PA_RunInMainProcess not compatible with PA_ObjectRef params */
            break;
    }
}

// ------------------------------ Text Input Context ------------------------------

void _o_INPUT_SOURCES_LIST(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param1;
    Param1.setSize(0);
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];
    
    if(currentInputContext)
    {
        Param1.appendUTF16String(@"");
        NSArray<NSString *> *keyboardInputSources = currentInputContext.keyboardInputSources;

        for (NSUInteger i = 0; i < [keyboardInputSources count]; ++i)
        {
            NSString *keyboardInputSource = [keyboardInputSources objectAtIndex:i];
            Param1.appendUTF16String(keyboardInputSource);
        }
    }

    Param1.toParamAtIndex(pParams, 1);
}

void SET_INPUT_SOURCE(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];
    
    if(currentInputContext)
    {
        NSString *selectedKeyboardInputSource = Param1.copyUTF16String();
        
        currentInputContext.selectedKeyboardInputSource = selectedKeyboardInputSource;
        
        [selectedKeyboardInputSource release];

    }

}

void SET_INPUT_SOURCE_LOCALES(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param1;

    Param1.fromParamAtIndex(pParams, 1);

    NSMutableArray<NSString *> *allowedInputSourceLocales = [[NSMutableArray<NSString *> alloc]initWithCapacity:Param1.getSize()];
    
    for(int i = 1; i < Param1.getSize(); ++i)
    {
        NSString *allowedInputSourceLocale = Param1.copyUTF16StringAtIndex(i);
        
        if([allowedInputSourceLocale isLike:@"ALL ROMAN INPUT SOURCES"])
        {
            [allowedInputSourceLocales addObject:NSAllRomanInputSourcesLocaleIdentifier];
        }else{
            if(![allowedInputSourceLocale isLike:@""])
            {
                [allowedInputSourceLocales addObject:allowedInputSourceLocale];
            }
        }
        
        [allowedInputSourceLocale release];
    }
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];
    
    if(currentInputContext)
    {
        currentInputContext.allowedInputSourceLocales = allowedInputSourceLocales;
    }
    
    [allowedInputSourceLocales release];
}

void GET_INPUT_SOURCE_LOCALES(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param1;
    Param1.setSize(0);
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];
    
    if(currentInputContext)
    {
        Param1.appendUTF16String(@"");
        NSArray<NSString *> *allowedInputSourceLocales = currentInputContext.allowedInputSourceLocales;
        
        
        for (NSUInteger i = 0; i < [allowedInputSourceLocales count]; ++i)
        {
            NSString *allowedInputSourceLocale = [allowedInputSourceLocales objectAtIndex:i];
            
            if([allowedInputSourceLocale isLike:NSAllRomanInputSourcesLocaleIdentifier])
            {
                Param1.appendUTF16String(@"ALL ROMAN INPUT SOURCES");
            }else{
                Param1.appendUTF16String(allowedInputSourceLocale);
            }
        }
    }

    Param1.toParamAtIndex(pParams, 1);
}

void INPUT_SOURCES_LIST(PA_PluginParameters params) {
    
    PA_CollectionRef sources = PA_CreateCollection();
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];

    if(currentInputContext)
    {
        NSArray<NSString *> *keyboardInputSources = currentInputContext.keyboardInputSources;

        for (NSUInteger i = 0; i < [keyboardInputSources count]; ++i)
        {
            NSString *keyboardInputSource = [keyboardInputSources objectAtIndex:i];
            
            PA_ObjectRef source = PA_CreateObject();

            ob_set_s(source, L"id", [keyboardInputSource UTF8String]);
            ob_set_s(source, L"name", [[NSTextInputContext localizedNameForInputSource:keyboardInputSource] UTF8String]);

            PA_Variable vObj = PA_CreateVariable(eVK_Object);
            PA_SetObjectVariable(&vObj, source);
            PA_SetCollectionElement(sources, PA_GetCollectionLength(sources), vObj);
            PA_ClearVariable(&vObj);
        }
    }

    PA_ReturnCollection(params, sources);
}

void Get_input_source(PA_PluginParameters params) {
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];

    if(currentInputContext)
    {
        NSString *selectedKeyboardInputSource = currentInputContext.selectedKeyboardInputSource;
        if(selectedKeyboardInputSource)
        {
            /* these are obtained using cocoa API */
            
            ob_set_s(returnValue, L"id", [selectedKeyboardInputSource UTF8String]);
            ob_set_s(returnValue, L"name", [[NSTextInputContext localizedNameForInputSource:selectedKeyboardInputSource] UTF8String]);
            
            /* these are obtained using carbon API */
            
            TISInputSourceRef inputSource = TISCopyCurrentKeyboardInputSource();
            if(inputSource)
            {
                CFStringRef category = (CFStringRef)TISGetInputSourceProperty(inputSource, kTISPropertyInputSourceCategory);
                if(category)
                {
                    ob_set_s(returnValue, L"category", [(__bridge NSString *)category UTF8String]);
                }
                CFStringRef type = (CFStringRef)TISGetInputSourceProperty(inputSource, kTISPropertyInputSourceType);
                if(type)
                {
                    ob_set_s(returnValue, L"type", [(__bridge NSString *)type UTF8String]);
                }
 
                CFArrayRef languages = (CFArrayRef)TISGetInputSourceProperty(inputSource, kTISPropertyInputSourceLanguages);
                if(languages)
                {
                    PA_CollectionRef colLanguages = PA_CreateCollection();
                    
                    for(CFIndex i =0; i < CFArrayGetCount(languages); ++i)
                    {
                        CFStringRef language = (CFStringRef)CFArrayGetValueAtIndex(languages, i);
                        if(language)
                        {
                            NSString *__language = (__bridge NSString *)language;
                            NSUInteger len = [__language length];
                            size_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
                            std::vector<uint8_t> buf(size);
                            PA_Unistring uStr;
                            
                            if([__language getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
                            {
                                uStr = PA_CreateUnistring((PA_Unichar *)&buf[0]);
                                PA_Variable vObj = PA_CreateVariable(eVK_Unistring);
                                PA_SetStringVariable(&vObj, &uStr);
                                PA_SetCollectionElement(colLanguages, PA_GetCollectionLength(colLanguages), vObj);
                                PA_ClearVariable(&vObj);
                            }
                        }
                    }
                    
                    ob_set_c(returnValue, L"languages", colLanguages);
                }
                
                NSImage *icon;
                NSURL *url = (NSURL *)TISGetInputSourceProperty(inputSource, kTISPropertyIconImageURL);
                if(url)
                {
                    icon = [[NSImage alloc]initWithContentsOfURL:url];
                    if(!icon)
                    {
                        //the extension is sometimes wrong; try again png -> tiff
                        url = [url.URLByDeletingPathExtension URLByAppendingPathExtension:@"tiff"];
                        icon = [[NSImage alloc]initWithContentsOfURL:url];
                    }
                    if(icon)
                    {
                        //return picture without memory leak; avoid the use of - TIFFRepresentation
                        NSRect imageRect = NSMakeRect(0, 0, icon.size.width , icon.size.height);
                        CGImageRef image = [icon CGImageForProposedRect:(NSRect *)&imageRect context:NULL hints:NULL];
                        CFMutableDataRef data = CFDataCreateMutable(kCFAllocatorDefault, 0);
                        CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypeTIFF, 1, NULL);
                        CFMutableDictionaryRef properties = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
                        CGImageDestinationAddImage(destination, image, properties);
                        CGImageDestinationFinalize(destination);
                        PA_Picture picture = PA_CreatePicture((void *)CFDataGetBytePtr(data), (PA_long32)CFDataGetLength(data));
                        ob_set_p(returnValue, L"icon", picture);
                        CFRelease(destination);
                        CFRelease(properties);
                        CFRelease(data);
                        [icon release];
                    }
                }
                else
                {
                    IconRef iconRef = (IconRef)TISGetInputSourceProperty(inputSource, kTISPropertyIconRef);
                    if(iconRef)
                    {
                        NSImage *icon = [[NSImage alloc]initWithIconRef:iconRef];
                        //return picture without memory leak; avoid the use of - TIFFRepresentation
                        NSRect imageRect = NSMakeRect(0, 0, icon.size.width , icon.size.height);
                        CGImageRef image = [icon CGImageForProposedRect:(NSRect *)&imageRect context:NULL hints:NULL];
                        CFMutableDataRef data = CFDataCreateMutable(kCFAllocatorDefault, 0);
                        CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypeTIFF, 1, NULL);
                        CFMutableDictionaryRef properties = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
                        CGImageDestinationAddImage(destination, image, properties);
                        CGImageDestinationFinalize(destination);
                        PA_Picture picture = PA_CreatePicture((void *)CFDataGetBytePtr(data), (PA_long32)CFDataGetLength(data));
                        ob_set_p(returnValue, L"icon", picture);
                        CFRelease(destination);
                        CFRelease(properties);
                        CFRelease(data);
                        [icon release];
                    }
                }
                
                CFRelease(inputSource);
            }
        }
    }

    PA_ReturnObject(params, returnValue);
}

void _o_Get_input_source(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    
    C_TEXT returnValue;
    
    NSTextInputContext *currentInputContext = [NSTextInputContext currentInputContext];
    
    if(currentInputContext)
    {
        NSString *selectedKeyboardInputSource = currentInputContext.selectedKeyboardInputSource;
        if(selectedKeyboardInputSource)
        {
            returnValue.setUTF16String(selectedKeyboardInputSource);
        }
    }
    
    returnValue.setReturn(pResult);
}
